# Content
The course will cover many of the fundamentals of operating systems: <br>
x86_64 assembly, virtual memory, processes, threads, process communications,deadlocks, scheduling, memory management, 
<br> I/O, filesystems, access control and security. The crux of the course will be projects and hands-on assignments.

# Learning outcome - Objectives
- Be able to explain the objectives and functions of modern operating systems.
- Be able to explain dynamic memory allocation in modern operating systems.
- Be able to describe the need for concurrency within the framework of an operating system.
- Be able to explain the memory hierarchy and cost-performance trade offs.
- Be able to describe the difference between processes and threads.
- Be able to discuss the need for a hardware cache, as well as common algorithms and optimizations used to implement it.
- Be able to explain signal handling within UNIX -based operating systems. <br><br>
- Be able to explain conditions that lead to deadlock.
- Be able to compare and contrast the common algorithms used for both preemptive and non- preemptive scheduling of tasks in operating systems, such as priority, performance comparison, and fair-share schemes.
- Be able to explain the concept of virtual memory and how it is realized in hardware and software.
- Be able to summarize the principles of virtual memory as applied to caching, paging, and segmentation.
- Be able to compare and contrast paging and segmentation techniques.
- Be able to disassemble, trace and perform rudimentary debugging of programs written in Intel x86_64 assembly.
- Be able to boot an operating system using a simulator.
- Be able to write a simple kernel module for the Linux kernel.
- Be able to write a buffer-overflow exploit.
- Be able to write working C code that interacts with standard C libraries and the operating system kernel directly.
- Be able to write a multi-threaded multi-tenant service using semaphores and mutexes.
- Be able to write a primitive command shell for UNIX-based operating systems.
- Be able to disassemble, trace and perform rudimentary debugging of programs written in Intel x86_64 assembly.
- Be able to boot an operating system using a simulator.
- Be able to write a simple kernel module for the Linux kernel.
- Be able to write a buffer-overflow exploit.
- Be able to write working C code that interacts with standard C libraries and the operating system kernel directly.
- Be able to write a multi-threaded multi-tenant service using semaphores and mutexes.
- Be able to write a primitive command shell for UNIX-based operating systems.

